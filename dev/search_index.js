var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/#Methods","page":"API","title":"Methods","text":"","category":"section"},{"location":"api/#Algorithms","page":"API","title":"Algorithms","text":"","category":"section"},{"location":"api/#StreamSampling.ReservoirSampler","page":"API","title":"StreamSampling.ReservoirSampler","text":"ReservoirSampler{T}([rng], method = AlgRSWRSKIP())\nReservoirSampler{T}([rng], n::Int, method = AlgL(); ordered = false)\n\nInitializes a reservoir sampler with elements of type T.\n\nThe first signature represents a sample where only a single element is collected. If ordered is true, the sampled values can be retrived in the order they were collected using ordvalue.\n\nLook at the Sampling Algorithms section for the supported methods. \n\n\n\n\n\n","category":"type"},{"location":"api/#StreamSampling.StreamSampler","page":"API","title":"StreamSampling.StreamSampler","text":"StreamSampler{T}([rng], iter, n, [N], method = AlgD())\n\nInitializes a stream sampler, which can then be iterated over to return the sampling elements of the iterable iter which is assumed to have a eltype of T. The methods implemented in StreamSampler require the knowledge of the total number of elements in the stream N, if not provided it is assumed to be available by calling length(iter).\n\n\n\nStreamSampler{T}([rng], iter, wfunc, n, W, method = AlgORDWSWR())\n\nInitializes a weigthed stream sampler, which can then be iterated over to return the sampling elements of the iterable iter which is assumed to have a eltype of T. The methods implemented in StreamSampler for weighted streams require the knowledge of the total weight of the stream W and a weight function wfunc specifying how to map an element to its weight. \n\n\n\n\n\n","category":"type"},{"location":"api/#StreamSampling.SequentialSampler","page":"API","title":"StreamSampling.SequentialSampler","text":"SequentialSampler([rng], n, N, method = AlgD())\n\nInitializes a sequential sampler, which can then be iterated over to return n ordered indices between 1 and N, respecting the sampling scheme of the selected method, which can be AlgD(), AlgHiddenShuffle() or AlgORDSWR().\n\n\n\n\n\n","category":"type"},{"location":"api/#StatsAPI.fit!","page":"API","title":"StatsAPI.fit!","text":"fit!(rs::AbstractReservoirSampler, el)\nfit!(rs::AbstractReservoirSampler, el, w)\n\nUpdates the reservoir sample by taking into account the element passed. If the sampling is weighted also the weight of the elements needs to be passed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.merge!","page":"API","title":"Base.merge!","text":"Base.merge!(rs::AbstractReservoirSampler...)\n\nUpdates the first reservoir sampler by merging its value with the values of the other samplers. The number of elements after merging will be the minimum number of elements in the merged reservoirs.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.merge","page":"API","title":"Base.merge","text":"Base.merge(rs::AbstractReservoirSampler...)\n\nCreates a new reservoir sampler by merging the values of the samplers passed. The number of elements in the new sampler will be the minimum number of elements in the merged reservoirs.\n\n\n\n\n\n","category":"function"},{"location":"api/#StreamSampling.combine","page":"API","title":"StreamSampling.combine","text":"combine([rng], samples::AbstractArray, weights::AbstractArray)\n\nCombines different stream samples in a single one. The number of  elements in the new sampler will be the minimum number of elements in the samples. weights should contain the weight of each stream, which in the unweighted case coincides with the length of the streams.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.empty!","page":"API","title":"Base.empty!","text":"Base.empty!(rs::AbstractReservoirSampler)\n\nResets the reservoir sample to its initial state.  Useful to avoid allocating a new sampler in some cases.\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsBase.value","page":"API","title":"OnlineStatsBase.value","text":"value(rs::AbstractReservoirSampler)\n\nReturns the elements collected in the sample at the current  sampling stage.\n\nIf the sampler is empty, it returns nothing for single element sampling. For multi-valued samplers, it always returns the sample collected so far instead.\n\nNote that even if the sampling respects the schema it is assigned when ReservoirSampler is instantiated, some ordering in  the sample can be more probable than others. To represent each one  with the same probability call fshuffle! on the result.\n\n\n\n\n\n","category":"function"},{"location":"api/#StreamSampling.ordvalue","page":"API","title":"StreamSampling.ordvalue","text":"ordvalue(rs::AbstractReservoirSampler)\n\nReturns the elements collected in the sample at the current  sampling stage in the order they were collected. This applies only when ordered = true is passed in ReservoirSampler.\n\nIf the sampler is empty, it returns nothing for single element sampling. For multi-valued samplers, it always returns the sample collected so far instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsAPI.nobs","page":"API","title":"StatsAPI.nobs","text":"nobs(rs::AbstractReservoirSampler)\n\nReturns the total number of elements that have been observed so far  during the sampling process.\n\n\n\n\n\n","category":"function"},{"location":"api/#StreamSampling.itsample","page":"API","title":"StreamSampling.itsample","text":"itsample([rng], iter, method = AlgRSWRSKIP())\nitsample([rng], iter, wfunc, method = AlgWRSWRSKIP())\n\nReturn a random element of the iterator, optionally specifying a rng  (which defaults to Random.default_rng()) and a function wfunc which accept each element as input and outputs the corresponding weight. If the iterator is empty, it returns nothing.\n\n\n\nitsample([rng], iter, n::Int, method = AlgL(); ordered = false)\nitsample([rng], iter, wfunc, n::Int, method = AlgAExpJ(); ordered = false)\n\nReturn a vector of n random elements of the iterator,  optionally specifying a rng (which defaults to Random.default_rng()), a weight function wfunc specifying how to map an element to its weight and a method. ordered dictates whether an ordered sample (also called a  sequential sample, i.e. a sample where items  appear in the same order as in iter) must be collected.\n\nIf the iterator has less than n elements, in the case of sampling without replacement, it returns a vector of those elements.\n\n\n\n\n\n","category":"function"},{"location":"api/#StreamSampling.AlgR","page":"API","title":"StreamSampling.AlgR","text":"Implements random reservoir sampling without replacement. To be used with ReservoirSampler or itsample.\n\nAdapted from algorithm R described in \"Random sampling with a reservoir, J. S. Vitter, 1985\".\n\n\n\n\n\n","category":"type"},{"location":"api/#StreamSampling.AlgL","page":"API","title":"StreamSampling.AlgL","text":"Implements random reservoir sampling without replacement. To be used with ReservoirSampler or itsample.\n\nAdapted from algorithm L described in \"Random sampling with a reservoir, J. S. Vitter, 1985\".\n\n\n\n\n\n","category":"type"},{"location":"api/#StreamSampling.AlgRSWRSKIP","page":"API","title":"StreamSampling.AlgRSWRSKIP","text":"Implements random reservoir sampling with replacement. To be used with ReservoirSampler or itsample.\n\nAdapted fron algorithm RSWR-SKIP described in \"Reservoir-based Random Sampling with Replacement from  Data Stream, B. Park et al., 2008\".\n\n\n\n\n\n","category":"type"},{"location":"api/#StreamSampling.AlgARes","page":"API","title":"StreamSampling.AlgARes","text":"Implements weighted random reservoir sampling without replacement. To be used with ReservoirSampler or itsample.\n\nAdapted from algorithm A-Res described in \"Weighted random sampling with a reservoir, P. S. Efraimidis, P. G. Spirakis, 2006\".\n\n\n\n\n\n","category":"type"},{"location":"api/#StreamSampling.AlgAExpJ","page":"API","title":"StreamSampling.AlgAExpJ","text":"Implements weighted random reservoir sampling without replacement. To be used with ReservoirSampler or itsample.\n\nAdapted from algorithm A-ExpJ described in \"Weighted random sampling with a reservoir, P. S. Efraimidis P. G. Spirakis, 2006\".\n\n\n\n\n\n","category":"type"},{"location":"api/#StreamSampling.AlgWRSWRSKIP","page":"API","title":"StreamSampling.AlgWRSWRSKIP","text":"Implements weighted random reservoir sampling with replacement. To be used with ReservoirSampler or itsample.\n\nAdapted from algorithm WRSWR-SKIP described in \"Investigating Methods for Weighted Reservoir Sampling with Replacement, A. Meligrana, 2024\".\n\n\n\n\n\n","category":"type"},{"location":"api/#StreamSampling.AlgD","page":"API","title":"StreamSampling.AlgD","text":"Implements random stream sampling without replacement. To be used with StreamSampler or itsample.\n\nAdapted from algorithm D described in \"An Efficient Algorithm for Sequential Random Sampling, J. S. Vitter, 1987\".\n\n\n\n\n\n","category":"type"},{"location":"api/#StreamSampling.AlgHiddenShuffle","page":"API","title":"StreamSampling.AlgHiddenShuffle","text":"Implements random stream sampling without replacement. To be used with StreamSampler or itsample.\n\nAdapted from algorithm HiddenShuffle described in \"Sequential Random Sampling Revisited: Hidden Shuffle Method, M. Shekelyan, G. Cormode, 2021\".\n\n\n\n\n\n","category":"type"},{"location":"api/#StreamSampling.AlgORDSWR","page":"API","title":"StreamSampling.AlgORDSWR","text":"Implements random stream sampling with replacement. To be used with StreamSampler or itsample.\n\nAdapted from algorithm 4 described in \"Generating Sorted Lists of Random Numbers, J. L. Bentley, J. B. Saxe, 1980\".\n\n\n\n\n\n","category":"type"},{"location":"api/#StreamSampling.AlgORDWSWR","page":"API","title":"StreamSampling.AlgORDWSWR","text":"Implements weighted random stream sampling with replacement. To be used with StreamSampler.\n\nAdapted from algorithm 3 described in \"An asymptotically optimal, online algorithm for weighted random sampling with replacement, M. Startek, 2016\".\n\n\n\n\n\n","category":"type"},{"location":"basics/#Overview-of-the-functionalities","page":"Basics","title":"Overview of the functionalities","text":"The itsample function allows to consume all the stream at once and return the sample collected:\n\nusing StreamSampling\n\nst = 1:100;\n\nitsample(st, 5)\n\nIn some cases, one needs to control the updates the ReservoirSampler will be subject to. In this case you can simply use the fit! function to update the reservoir:\n\nst = 1:100;\n\nrs = ReservoirSampler{Int}(5);\n\nfor x in st\n    fit!(rs, x)\nend\n\nvalue(rs)\n\nIf the total number of elements in the stream is known beforehand and the sampling is unweighted, it is also possible to iterate over a StreamSampler like so\n\nst = 1:100;\n\nss = StreamSampler{Int}(st, 5, 100);\n\nr = Int[];\n\nfor x in ss\n    push!(r, x)\nend\n\nr\n\nThe advantage of StreamSampler iterators in respect to ReservoirSampler is that they require O(1) memory if not collected, while reservoir techniques require O(k) memory where k is the number of elements in the sample.","category":"section"},{"location":"perf_tips/#Performance-Tips","page":"Performance Tips","title":"Performance Tips","text":"","category":"section"},{"location":"perf_tips/#Use-Immutable-Reservoir-Samplers","page":"Performance Tips","title":"Use Immutable Reservoir Samplers","text":"By default, a ReservoirSampler is mutable, however, it is also possible to use an immutable version which supports all the basic operations. It uses Accessors.jl under the hood to update the reservoir.\n\nLet's compare the performance of mutable and immutable samplers with a simple benchmark\n\nusing StreamSampling, BenchmarkTools\n\nfunction fit_iter!(rs, iter)\n    for i in iter\n        rs = fit!(rs, i) # the reassignment is necessary when `rs` is immutable\n    end\n    return rs\nend\n\niter = 1:10^7;\n\nRunning with both version we get\n\n@btime fit_iter!(rs, $iter) setup=(rs = ReservoirSampler{Int}(10, AlgRSWRSKIP(); mutable = true))\n\n  6.535 ms (2 allocations: 144 bytes)\n\n@btime fit_iter!(rs, $iter) setup=(rs = ReservoirSampler{Int}(10, AlgRSWRSKIP(); mutable = false))\n\n  4.816 ms (2 allocations: 144 bytes)\n\nAs you can see, the immutable version is 50% faster than  the mutable one. In general, the smaller the ratio between reservoir  size and stream size, the faster the immutable version will be than the mutable one. Be careful though, because calling fit! on an immutable sampler won't modify it in-place, but only create a new updated instance.","category":"section"},{"location":"perf_tips/#Parallel-Sampling-from-Multiple-Streams","page":"Performance Tips","title":"Parallel Sampling from Multiple Streams","text":"Let's say that you want to split the sampling of an iterator. If you can split the iterator into different partitions then you can update in parallel a reservoir sample for each partition and then merge them together at the end.\n\nSuppose for instance to have these 2 iterators\n\niters = [1:100, 101:200]\n\nthen you create two reservoirs of the same type\n\nrs = [ReservoirSampler{Int}(10, AlgRSWRSKIP()) for i in 1:length(iters)]\n\nand after that you can just update them in parallel like so\n\nThreads.@threads for i in 1:length(iters)\n    for e in iters[i]\n        fit!(rs[i], e)\n    end\nend\n\nthen you can obtain a unique reservoir containing a summary of the union of the streams with\n\nmerge(rs...)","category":"section"},{"location":"benchmark/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmark/#Sampling-Iterators","page":"Benchmarks","title":"Sampling Iterators","text":"Using these sampling techniques can bring down considerably the memory usage of the program,  but there are cases where they are also more time efficient:\n\n(Image: )\n\nThe iterator used is a filtered generator which creates an integer range between 1 and 10^8. The filtering step is performed to make the benchmark more accurately mimic a somewhat realistic iterator, on which the methods could be actually used in practice.\n\nThe “population” methods use StatsBase.sample and consider collecting the iterator in memory as part of the benchmark. The reservoir and stream methods use instead ReservoirSampler and StreamSampler of this package.\n\nThe code to reproduce the results is at StreamSampling.jl/benchmark/benchmarkcomparisonstream.jl.","category":"section"},{"location":"benchmark/#Sampling-Persistent-Data","page":"Benchmarks","title":"Sampling Persistent Data","text":"We also tried to evaluate the performance of the procedures on persistent data. Here we measure the performance of weighted sampling with replacement from 100 GB of data in the arrow format stored on disk:\n\n(Image: comparison_ondisk_algs)\n\nthe \"chunks\" method uses StatsBase.sample along with the merging methods of this package to sample subsequent chunks of the stored data and then recombine the samples. The other methods employ the same methodologies as in the previous benchmark.\n\nAs you can see, using a ReservoirSampler in this case beats all other methods. This is partly due to its single-pass nature, in contrast to streaming methods which usually require two passes (though the first pass which computes the total weight is faster than the second one which extracts the sample).\n\nThe code to reproduce the results is at StreamSampling.jl/benchmark/benchmark_ondisk.jl.","category":"section"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"using Pkg\nPkg.add(\"StreamSampling\")","category":"section"},{"location":"#Reproducibility","page":"Introduction","title":"Reproducibility","text":"<details><summary>The documentation of StreamSampling.jl was built using these direct dependencies,</summary>\n\nusing Pkg # hide\nPkg.status() # hide\n\n</details>\n\n<details><summary>and using this machine and Julia version.</summary>\n\nusing InteractiveUtils # hide\nversioninfo() # hide\n\n</details>\n\n<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>\n\nusing Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide\n\n</details>\n\nusing TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/StreamSampling/\" * name * \".jl/tree/gh-pages/v\" * version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/StreamSampling/\" * name * \".jl/tree/gh-pages/v\" * version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"section"},{"location":"#StreamSampling","page":"Introduction","title":"StreamSampling","text":"StreamSampling.jl\n\n(Image: CI) (Image: ) (Image: codecov) (Image: Aqua QA) (Image: DOI)\n\nThe scope of this package is to provide general methods to sample from any stream in a single pass through the data, even when  the number of items contained in the stream is unknown.\n\nThis has some advantages over other sampling procedures:\n\nIf the iterable is lazy, the memory required is a small constant or grows in relation to the size of the sample, instead of all the population.\nWith reservoir methods, the sample collected is a random sample of the portion of the stream seen thus far at any point of the sampling process.\nIn some cases, sampling with the techniques implemented in this library can bring considerable performance gains, since the population of items doesn't need to be previously stored in memory.\n\nFor information about the available functionalities consult the documentation.\n\nContributing\n\nContributions are welcome! If you encounter any issues, have suggestions for improvements, or would like to add new  features, feel free to open an issue or submit a pull request.\n\n\n\n\n\n","category":"module"},{"location":"example/#Some-Applications","page":"Some Applications","title":"Some Applications","text":"","category":"section"},{"location":"example/#Sampling-from-Data-on-Disk","page":"Some Applications","title":"Sampling from Data on Disk","text":"Suppose we want to sample from large datasets stored on disk. StreamSampling.jl is very suited for this task. Let's simulate this task by generating some data in  HDF5 and arrow formats and batch sampling them. You will need 20GB of space on disk for running this example. If not available you can set a smaller size for totaltpl.\n\nWe first generate the datasets and store them with\n\nusing StreamSampling, Random, ChunkSplitters\nusing HDF5, Arrow\n\nconst dtype = @NamedTuple{a::Float64, b::Float64, c::Float64, d::Float64}\nconst totaltpl = 10^10÷32\nconst chunktpl = 5*10^5\nconst numchunks = ceil(Int, totaltpl / chunktpl)\n\nfunction generate_file(filename, format)\n    if format == :hdf5\n        h5open(filename, \"w\") do file\n            dset = create_dataset(file, \"data\", dtype, (totaltpl,), chunk=(chunktpl,))\n            Threads.@threads for i in 1:numchunks\n                starttpl, endtpl = (i-1)*chunktpl+1, min(i*chunktpl, totaltpl)\n                dset[starttpl:endtpl] = map(i -> (a=rand(), b=rand(), c=rand(), d=rand()), \n                                            1:endtpl-starttpl+1)\n            end\n        end\n    elseif format == :arrow\n        for i in 1:numchunks\n            starttpl, endtpl = (i-1)*chunktpl+1, min(i*chunktpl, totaltpl)\n            Arrow.append(\"random_data.arrow\", (data=map(i -> (a=rand(), b=rand(), c=rand(), d=rand()), \n                                               1:endtpl-starttpl+1),);file=false)\n        end\n    end\nend\n\n!isfile(\"random_data.h5\") && generate_file(\"random_data.h5\", :hdf5)\n!isfile(\"random_data.arrow\") && generate_file(\"random_data.arrow\", :arrow)\n\nThen we can sample them using 1 thread with\n\nfunction sample_file(filename, rng, n, alg, format)\n    rs = ReservoirSampler{dtype}(rng, n, alg)\n    if format == :hdf5\n        h5open(filename, \"r\") do file\n            dset = file[\"data\"]\n            for i in 1:numchunks\n                starttpl, endtpl = (i-1)*chunktpl+1, min(i*chunktpl, totaltpl)\n                data_chunk = dset[starttpl:endtpl]\n                for d in data_chunk\n                    fit!(rs, d)\n                end\n            end\n        end\n    elseif format == :arrow\n        rs = ReservoirSampler{dtype}(rng, n, alg)\n        data = Arrow.Table(filename).data\n        @inbounds for i in 1:length(data)\n            fit!(rs, data[i])\n        end\n    end\n    return rs\nend\n\nrng = Xoshiro(42)\n@time rs = sample_file(\"random_data.h5\", rng, 10^7, AlgRSWRSKIP(), :hdf5)\n\n 43.514238 seconds (937.21 M allocations: 42.502 GiB, 2.57% gc time)\n\n@time rs = sample_file(\"random_data.arrow\", rng, 10^7, AlgRSWRSKIP(), :arrow)\n\n 38.635389 seconds (1.25 G allocations: 33.500 GiB, 3.52% gc time, 75763 lock conflicts)\n\nWe can try to improve the performance by using multiple threads. Here, I started Julia with julia -t4 --gcthreads=4,1 on my machine\n\nfunction psample_file(filename, rngs, n, alg, format)\n    rsv = [ReservoirSampler{dtype}(rngs[i], n, alg) for i in 1:Threads.nthreads()]\n    if format == :hdf5\n        h5open(filename, \"r\") do file\n            dset = file[\"data\"]\n            for c in chunks(1:numchunks; n=ceil(Int, numchunks/Threads.nthreads()))\n                Threads.@threads for (j, i) in collect(enumerate(c))\n                    starttpl, endtpl = (i-1)*chunktpl+1, min(i*chunktpl, totaltpl)\n                    data_chunk, rs = dset[starttpl:endtpl], rsv[j]\n                    for d in data_chunk\n                        fit!(rs, d)\n                    end\n                end\n            end\n        end\n    elseif format == :arrow\n        data = Arrow.Table(filename).data\n        Threads.@threads for (i,c) in enumerate(chunks(1:length(data), n=Threads.nthreads()))\n            @inbounds for j in c\n                fit!(rsv[i], data[j])\n            end\n        end\n    end\n    return merge(rsv...)\nend\n\nrngs = [Xoshiro(i) for i in 1:Threads.nthreads()]\n@time rs = psample_file(\"random_data.h5\", rngs, 10^7, AlgRSWRSKIP(), :hdf5)\n\n 23.240628 seconds (937.23 M allocations: 45.185 GiB, 9.52% gc time, 9375 lock conflicts)\n\n@time rs = psample_file(\"random_data.arrow\", rngs, 10^7, AlgRSWRSKIP(), :arrow)\n\n 5.868995 seconds (175.91 k allocations: 3.288 GiB, 6.44% gc time, 64714 lock conflicts)\n\nAs you can see, the speed-up is not linear in the number of threads for an hdf5 file. This is mainly due to the fact that accessing the chunks is single-threaded, so one would need to use MPI.jl as  explained at HDF5.jl/stable/mpi/ to improve the multi-threading performance. Though, we are already sampling at 500MB/s, which is not bad! Using Arrow.jl gives an even better performance, and a scalability which is better than linear somehow, reaching a 2GB/s sampling speed!","category":"section"},{"location":"example/#Monitoring","page":"Some Applications","title":"Monitoring","text":"Suppose to receive data about some process in the form of a stream and you want to detect if anything is going wrong in the data being received. A reservoir  sampling approach could be useful to evaluate properties on the data stream.  This is a demonstration of such a use case using StreamSampling.jl. We will assume that the monitored statistic in this case is the mean of the data, and  you want that to be lower than a certain threshold otherwise some malfunctioning is expected\n\nusing StreamSampling, Statistics, Random\n\nfunction monitor(stream, thr)\n    rng = Xoshiro(42)\n    # we use a reservoir sample of 10^4 elements\n    rs = ReservoirSampler{Int}(rng, 10^4)\n    # we loop over the stream and fit the data in the reservoir\n    for (i, e) in enumerate(stream)\n        fit!(rs, e)\n        # we check the mean value every 1000 iterations\n        if iszero(mod(i, 1000)) && mean(value(rs)) >= thr\n            return rs\n        end\n    end\nend\n\nWe use some toy data for illustration\n\nstream = 1:10^8; # the data stream\nthr = 2*10^7; # the threshold for the mean monitoring\n\nThen, we run the monitoring\n\nrs = monitor(stream, thr);\n\nThe number of observations until the detection is triggered is given by\n\nnobs(rs)\n\nwhich is very close to the true value of 4*10^7 - 1 observations.\n\nNote that in this case we could use an online mean methods,  instead of holding all the sample into memory. However,  the approach with the sample is more general because it allows to estimate any statistic about the stream. ","category":"section"}]
}
