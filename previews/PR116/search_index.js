var documenterSearchIndex = {"docs":
[{"location":"api.html#API","page":"API","title":"API","text":"","category":"section"},{"location":"api.html#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api.html#StreamSampling.ReservoirSampler","page":"API","title":"StreamSampling.ReservoirSampler","text":"ReservoirSampler{T}([rng], method = AlgRSWRSKIP())\nReservoirSampler{T}([rng], n::Int, method = AlgL(); ordered = false)\n\nInitializes a reservoir sampler with elements of type T.\n\nThe first signature represents a sample where only a single element is collected. If ordered is true, the sampled values can be retrived in the order they were collected using ordvalue.\n\nLook at the Sampling Algorithms section for the supported methods. \n\n\n\n\n\n","category":"type"},{"location":"api.html#StreamSampling.StreamSampler","page":"API","title":"StreamSampling.StreamSampler","text":"StreamSampler{T}([rng], iter, n, [N], method = AlgD())\n\nInitializes a stream sampler, which can then be iterated over to return the sampling elements of the iterable iter which is assumed to have a eltype of T. The methods implemented in StreamSampler require the knowledge of the total number of elements in the stream N, if not provided it is assumed to be available by calling length(iter).\n\n\n\n\n\n","category":"type"},{"location":"api.html#Methods","page":"API","title":"Methods","text":"","category":"section"},{"location":"api.html#StatsAPI.fit!","page":"API","title":"StatsAPI.fit!","text":"Fit a statistical model in-place.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Base.merge!","page":"API","title":"Base.merge!","text":"merge!(d::AbstractDict, others::AbstractDict...)\n\nUpdate collection with pairs from the other collections. See also merge.\n\nExamples\n\njulia> d1 = Dict(1 => 2, 3 => 4);\n\njulia> d2 = Dict(1 => 4, 4 => 5);\n\njulia> merge!(d1, d2);\n\njulia> d1\nDict{Int64, Int64} with 3 entries:\n  4 => 5\n  3 => 4\n  1 => 4\n\n\n\n\n\nmerge!(ct1::Accumulator, others...)\n\nMerges the other counters into ctl, summing the counts for all elements.\n\n\n\n\n\nmerge!(sc, sc1...)\n\nThis updates sc by merging SortedDicts or SortedMultiDicts sc1, etc. into sc. These must all must have the same key-value types. In the case of keys duplicated among the arguments, the rightmost argument that owns the key gets its value stored for SortedDict. In the case of SortedMultiDict all the key-value pairs are stored, and for overlapping keys the ordering is left-to-right. This function is not available for SortedSet, but the union! function (see below) provides equivalent functionality. Time: O(cN log N), where N is the total size of all the arguments.\n\n\n\n\n\nmerge!(sc, sc1...)\n\nThis updates sc by merging SortedDicts or SortedMultiDicts sc1, etc. into sc. These must all must have the same key-value types. In the case of keys duplicated among the arguments, the rightmost argument that owns the key gets its value stored for SortedDict. In the case of SortedMultiDict all the key-value pairs are stored, and for overlapping keys the ordering is left-to-right. This function is not available for SortedSet, but the union! function (see below) provides equivalent functionality. Time: O(cN log N), where N is the total size of all the arguments.\n\n\n\n\n\nmerge!(target::Histogram, others::Histogram...)\n\nUpdate histogram target by merging it with the histograms others. See merge(histogram::Histogram, others::Histogram...) for details.\n\n\n\n\n\nmerge!(a, b)\n\nMerge OnlineStat b into a (supported by most OnlineStat types).\n\nExample\n\na = fit!(Mean(), 1:10)\nb = fit!(Mean(), 11:20)\nmerge!(a, b)\n\n\n\n\n\nBase.merge!(rs::AbstractReservoirSampler, rs_others::AbstractReservoirSampler...)\n\nUpdates the first reservoir sampler by merging its value with the values of the other samplers. The number of elements after merging will be the minimum number of elements in the merged reservoirs.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Base.merge","page":"API","title":"Base.merge","text":"merge(d::AbstractDict, others::AbstractDict...)\n\nConstruct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. If the same key is present in another collection, the value for that key will be the value it has in the last collection listed. See also mergewith for custom handling of values with the same key.\n\nExamples\n\njulia> a = Dict(\"foo\" => 0.0, \"bar\" => 42.0)\nDict{String, Float64} with 2 entries:\n  \"bar\" => 42.0\n  \"foo\" => 0.0\n\njulia> b = Dict(\"baz\" => 17, \"bar\" => 4711)\nDict{String, Int64} with 2 entries:\n  \"bar\" => 4711\n  \"baz\" => 17\n\njulia> merge(a, b)\nDict{String, Float64} with 3 entries:\n  \"bar\" => 4711.0\n  \"baz\" => 17.0\n  \"foo\" => 0.0\n\njulia> merge(b, a)\nDict{String, Float64} with 3 entries:\n  \"bar\" => 42.0\n  \"baz\" => 17.0\n  \"foo\" => 0.0\n\n\n\n\n\nmerge(a::NamedTuple, bs::NamedTuple...)\n\nConstruct a new named tuple by merging two or more existing ones, in a left-associative manner. Merging proceeds left-to-right, between pairs of named tuples, and so the order of fields present in both the leftmost and rightmost named tuples take the same position as they are found in the leftmost named tuple. However, values are taken from matching fields in the rightmost named tuple that contains that field. Fields present in only the rightmost named tuple of a pair are appended at the end. A fallback is implemented for when only a single named tuple is supplied, with signature merge(a::NamedTuple).\n\ncompat: Julia 1.1\nMerging 3 or more NamedTuple requires at least Julia 1.1.\n\nExamples\n\njulia> merge((a=1, b=2, c=3), (b=4, d=5))\n(a = 1, b = 4, c = 3, d = 5)\n\njulia> merge((a=1, b=2), (b=3, c=(d=1,)), (c=(d=2,),))\n(a = 1, b = 3, c = (d = 2,))\n\n\n\n\n\nmerge(a::NamedTuple, iterable)\n\nInterpret an iterable of key-value pairs as a named tuple, and perform a merge.\n\njulia> merge((a=1, b=2, c=3), [:b=>4, :d=>5])\n(a = 1, b = 4, c = 3, d = 5)\n\n\n\n\n\n merge(counters...)\n\nCreates a new counter with total counts equal to the sum of the counts in the counters given as arguments.\n\nSee also merge!\n\n\n\n\n\nmerge(sc1, sc2...)\n\nThis returns a SortedDict or SortedMultiDict that results from merging SortedDicts or SortedMultiDicts sc1, sc2, etc., which all must have the same key-value-ordering types. In the case of keys duplicated among the arguments, the rightmost argument that owns the key gets its value stored for SortedDict. In the case of SortedMultiDict all the key-value pairs are stored, and for keys shared between sc1 and sc2 the ordering is left-to-right. This function is not available for SortedSet, but the union function (see below) provides equivalent functionality. Time: O(cN log N), where N is the total size of all the arguments.\n\n\n\n\n\nmerge(sc1, sc2...)\n\nThis returns a SortedDict or SortedMultiDict that results from merging SortedDicts or SortedMultiDicts sc1, sc2, etc., which all must have the same key-value-ordering types. In the case of keys duplicated among the arguments, the rightmost argument that owns the key gets its value stored for SortedDict. In the case of SortedMultiDict all the key-value pairs are stored, and for keys shared between sc1 and sc2 the ordering is left-to-right. This function is not available for SortedSet, but the union function (see below) provides equivalent functionality. Time: O(cN log N), where N is the total size of all the arguments.\n\n\n\n\n\nmerge(h::Histogram, others::Histogram...)\n\nConstruct a new histogram by merging h with others. All histograms must have the same binning, shape of weights and properties (closed and isdensity). The weights of all histograms are summed up for each bin, the weights of the resulting histogram will have the same type as those of h.\n\n\n\n\n\nBase.merge(rs_all::AbstractReservoirSampler...)\n\nCreates a new reservoir sampler by merging the values of the samplers passed. The number of elements in the new sampler will be the minimum number of elements in the merged reservoirs.\n\n\n\n\n\nmerge(initial::Face, others::Face...)\n\nMerge the properties of the initial face and others, with later faces taking priority.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Base.empty!","page":"API","title":"Base.empty!","text":"empty!(collection) -> collection\n\nRemove all elements from a collection.\n\nExamples\n\njulia> A = Dict(\"a\" => 1, \"b\" => 2)\nDict{String, Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> empty!(A);\n\njulia> A\nDict{String, Int64}()\n\n\n\n\n\nempty!(c::Channel)\n\nEmpty a Channel c by calling empty! on the internal buffer. Return the empty channel.\n\n\n\n\n\nempty!(q::Deque{T})\n\nReset the deque.\n\n\n\n\n\nempty!(collection) -> collection\n\nRemove all elements from a collection.\n\nExamples\n\njulia> A = RobinDict(\"a\" => 1, \"b\" => 2)\nRobinDict{String, Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> empty!(A);\n\njulia> A\nRobinDict{String, Int64}()\n\n\n\n\n\nempty!(collection) -> collection\n\nRemove all elements from a collection.\n\nExamples\n\njulia> A = OrderedRobinDict(\"a\" => 1, \"b\" => 2)\nOrderedRobinDict{String, Int64} with 2 entries:\n  \"a\" => 1\n  \"b\" => 2\n\njulia> empty!(A);\n\njulia> A\nOrderedRobinDict{String, Int64}()\n\n\n\n\n\nempty!(collection) -> collection\n\nRemove all elements from a collection.\n\nExamples\n\njulia> A = SwissDict(\"a\" => 1, \"b\" => 2)\nSwissDict{String, Int64} with 2 entries:\n  \"a\" => 1\n  \"b\" => 2\n\njulia> empty!(A);\n\njulia> A\nSwissDict{String, Int64}()\n\n\n\n\n\nempty!(cb::CircularBuffer)\n\nReset the buffer.\n\n\n\n\n\nBase.empty!(rs::AbstractReservoirSampler)\n\nResets the reservoir sample to its initial state.  Useful to avoid allocating a new sampler in some cases.\n\n\n\n\n\nempty!(node.children::NodeChildren) -> NodeChildren\n\nRemoves all the children of a node.\n\n\n\n\n\n","category":"function"},{"location":"api.html#OnlineStatsBase.value","page":"API","title":"OnlineStatsBase.value","text":"value(stat::OnlineStat)\n\nCalculate the value of stat from its \"sufficient statistics\".\n\n\n\n\n\nvalue(rs::AbstractReservoirSampler)\n\nReturns the elements collected in the sample at the current  sampling stage.\n\nIf the sampler is empty, it returns nothing for single element sampling. For multi-valued samplers, it always returns the sample collected so far instead.\n\nNote that even if the sampling respects the schema it is assigned when ReservoirSampler is instantiated, some ordering in  the sample can be more probable than others. To represent each one  with the same probability call fshuffle! on the result.\n\n\n\n\n\n","category":"function"},{"location":"api.html#StreamSampling.ordvalue","page":"API","title":"StreamSampling.ordvalue","text":"ordvalue(rs::AbstractReservoirSampler)\n\nReturns the elements collected in the sample at the current  sampling stage in the order they were collected. This applies only when ordered = true is passed in ReservoirSampler.\n\nIf the sampler is empty, it returns nothing for single element sampling. For multi-valued samplers, it always returns the sample collected so far instead.\n\n\n\n\n\n","category":"function"},{"location":"api.html#StatsAPI.nobs","page":"API","title":"StatsAPI.nobs","text":"nobs(model::StatisticalModel)\n\nReturn the number of independent observations on which the model was fitted. Be careful when using this information, as the definition of an independent observation may vary depending on the model, on the format used to pass the data, on the sampling plan (if specified), etc.\n\n\n\n\n\n","category":"function"},{"location":"api.html#StreamSampling.itsample","page":"API","title":"StreamSampling.itsample","text":"itsample([rng], iter, method = AlgRSWRSKIP())\nitsample([rng], iter, wfunc, method = AlgWRSWRSKIP())\n\nReturn a random element of the iterator, optionally specifying a rng  (which defaults to Random.default_rng()) and a function wfunc which accept each element as input and outputs the corresponding weight. If the iterator is empty, it returns nothing.\n\n\n\nitsample([rng], iter, n::Int, method = AlgL(); ordered = false)\nitsample([rng], iter, wfunc, n::Int, method = AlgAExpJ(); ordered = false)\n\nReturn a vector of n random elements of the iterator,  optionally specifying a rng (which defaults to Random.default_rng()) a weight function wfunc and a method. ordered dictates whether an  ordered sample (also called a sequential sample, i.e. a sample where items  appear in the same order as in iter) must be collected.\n\nIf the iterator has less than n elements, in the case of sampling without replacement, it returns a vector of those elements.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Algorithms","page":"API","title":"Algorithms","text":"","category":"section"},{"location":"api.html#StreamSampling.AlgR","page":"API","title":"StreamSampling.AlgR","text":"Implements random reservoir sampling without replacement. To be used with ReservoirSampler or itsample.\n\nAdapted from algorithm R described in \"Random sampling with a reservoir, J. S. Vitter, 1985\".\n\n\n\n\n\n","category":"type"},{"location":"api.html#StreamSampling.AlgL","page":"API","title":"StreamSampling.AlgL","text":"Implements random reservoir sampling without replacement. To be used with ReservoirSampler or itsample.\n\nAdapted from algorithm L described in \"Random sampling with a reservoir, J. S. Vitter, 1985\".\n\n\n\n\n\n","category":"type"},{"location":"api.html#StreamSampling.AlgRSWRSKIP","page":"API","title":"StreamSampling.AlgRSWRSKIP","text":"Implements random reservoir sampling with replacement. To be used with ReservoirSampler or itsample.\n\nAdapted fron algorithm RSWR-SKIP described in \"Reservoir-based Random Sampling with Replacement from  Data Stream, B. Park et al., 2008\".\n\n\n\n\n\n","category":"type"},{"location":"api.html#StreamSampling.AlgARes","page":"API","title":"StreamSampling.AlgARes","text":"Implements weighted random reservoir sampling without replacement. To be used with ReservoirSampler or itsample.\n\nAdapted from algorithm A-Res described in \"Weighted random sampling with a reservoir, P. S. Efraimidis et al., 2006\".\n\n\n\n\n\n","category":"type"},{"location":"api.html#StreamSampling.AlgAExpJ","page":"API","title":"StreamSampling.AlgAExpJ","text":"Implements weighted random reservoir sampling without replacement. To be used with ReservoirSampler or itsample.\n\nAdapted from algorithm A-ExpJ described in \"Weighted random sampling with a reservoir, P. S. Efraimidis et al., 2006\".\n\n\n\n\n\n","category":"type"},{"location":"api.html#StreamSampling.AlgWRSWRSKIP","page":"API","title":"StreamSampling.AlgWRSWRSKIP","text":"Implements weighted random reservoir sampling with replacement. To be used with ReservoirSampler or itsample.\n\nAdapted from algorithm WRSWR-SKIP described in \"Investigating Methods for Weighted Reservoir Sampling with Replacement, A. Meligrana, 2024\".\n\n\n\n\n\n","category":"type"},{"location":"api.html#StreamSampling.AlgD","page":"API","title":"StreamSampling.AlgD","text":"Implements random stream sampling without replacement. To be used with StreamSampler or itsample.\n\nAdapted from algorithm D described in \"An Efficient Algorithm for Sequential Random Sampling, J. S. Vitter, 1987\".\n\n\n\n\n\n","category":"type"},{"location":"api.html#StreamSampling.AlgORDSWR","page":"API","title":"StreamSampling.AlgORDSWR","text":"Implements random stream sampling with replacement. To be used with StreamSampler or itsample.\n\nAdapted from algorithm 4 described in \"Generating Sorted Lists of Random Numbers, J. L. Bentley et al., 1980\".\n\n\n\n\n\n","category":"type"},{"location":"basics.html#Overview-of-the-functionalities","page":"Basics","title":"Overview of the functionalities","text":"","category":"section"},{"location":"basics.html","page":"Basics","title":"Basics","text":"The itsample function allows to consume all the stream at once and return the sample collected:","category":"page"},{"location":"basics.html","page":"Basics","title":"Basics","text":"using StreamSampling\n\nst = 1:100;\n\nitsample(st, 5)","category":"page"},{"location":"basics.html","page":"Basics","title":"Basics","text":"In some cases, one needs to control the updates the ReservoirSampler will be subject to. In this case you can simply use the fit! function to update the reservoir:","category":"page"},{"location":"basics.html","page":"Basics","title":"Basics","text":"st = 1:100;\n\nrs = ReservoirSampler{Int}(5);\n\nfor x in st\n    fit!(rs, x)\nend\n\nvalue(rs)","category":"page"},{"location":"basics.html","page":"Basics","title":"Basics","text":"If the total number of elements in the stream is known beforehand and the sampling is unweighted, it is also possible to iterate over a StreamSampler like so","category":"page"},{"location":"basics.html","page":"Basics","title":"Basics","text":"st = 1:100;\n\nss = StreamSampler{Int}(st, 5, 100);\n\nr = Int[];\n\nfor x in ss\n    push!(r, x)\nend\n\nr","category":"page"},{"location":"basics.html","page":"Basics","title":"Basics","text":"The advantage of StreamSampler iterators in respect to ReservoirSampler is that they require O(1) memory if not collected, while reservoir techniques require O(k) memory where k is the number of elements in the sample.","category":"page"},{"location":"basics.html","page":"Basics","title":"Basics","text":"Consult the API page for more information about the package interface.","category":"page"},{"location":"perf_tips.html#Use-Immutable-Reservoir-Samplers","page":"Performance Tips","title":"Use Immutable Reservoir Samplers","text":"","category":"section"},{"location":"perf_tips.html","page":"Performance Tips","title":"Performance Tips","text":"By default, a ReservoirSampler is mutable, however, it is also possible to use an immutable version which supports all the basic operations. It uses Accessors.jl under the hood to update the reservoir.","category":"page"},{"location":"perf_tips.html","page":"Performance Tips","title":"Performance Tips","text":"Let's compare the performance of mutable and immutable samplers with a simple benchmark","category":"page"},{"location":"perf_tips.html","page":"Performance Tips","title":"Performance Tips","text":"using StreamSampling, BenchmarkTools\n\nfunction fit_iter!(rs, iter)\n\tfor i in iter\n\t\trs = fit!(rs, i) # the reassignment is necessary when `rs` is immutable\n\tend\n\treturn rs\nend\n\niter = 1:10^7;","category":"page"},{"location":"perf_tips.html","page":"Performance Tips","title":"Performance Tips","text":"Running with both version we get","category":"page"},{"location":"perf_tips.html","page":"Performance Tips","title":"Performance Tips","text":"@btime fit_iter!(rs, $iter) setup=(rs = ReservoirSampler{Int}(10, AlgRSWRSKIP(); mutable = true))","category":"page"},{"location":"perf_tips.html","page":"Performance Tips","title":"Performance Tips","text":"@btime fit_iter!(rs, $iter) setup=(rs = ReservoirSampler{Int}(10, AlgRSWRSKIP(); mutable = false))","category":"page"},{"location":"perf_tips.html","page":"Performance Tips","title":"Performance Tips","text":"As you can see, the immutable version is 50% faster than  the mutable one. In general, more the ratio between reservoir  size and stream size is smaller, more the immutable version will be faster than the mutable one. Be careful though, because calling fit! on an immutable sampler won't modify it in-place, but only create a new updated instance.","category":"page"},{"location":"perf_tips.html#Parallel-Sampling-from-Multiple-Streams","page":"Performance Tips","title":"Parallel Sampling from Multiple Streams","text":"","category":"section"},{"location":"perf_tips.html","page":"Performance Tips","title":"Performance Tips","text":"Let's say that you want to split the sampling of an iterator. If you can split the iterator into different partitions then you can update in parallel a reservoir sample for each partition and then merge them together at the end.","category":"page"},{"location":"perf_tips.html","page":"Performance Tips","title":"Performance Tips","text":"Suppose for instance to have these 2 iterators","category":"page"},{"location":"perf_tips.html","page":"Performance Tips","title":"Performance Tips","text":"iters = [1:100, 101:200]","category":"page"},{"location":"perf_tips.html","page":"Performance Tips","title":"Performance Tips","text":"then you create two reservoirs of the same type","category":"page"},{"location":"perf_tips.html","page":"Performance Tips","title":"Performance Tips","text":"rs = [ReservoirSampler{Int}(10, AlgRSWRSKIP()) for i in 1:length(iters)]","category":"page"},{"location":"perf_tips.html","page":"Performance Tips","title":"Performance Tips","text":"and after that you can just update them in parallel like so","category":"page"},{"location":"perf_tips.html","page":"Performance Tips","title":"Performance Tips","text":"Threads.@threads for i in 1:length(iters)\n\tfor e in iters[i]\n\t\tfit!(rs[i], e)\n\tend\nend","category":"page"},{"location":"perf_tips.html","page":"Performance Tips","title":"Performance Tips","text":"then you can obtain a unique reservoir containing a summary of the union of the streams with","category":"page"},{"location":"perf_tips.html","page":"Performance Tips","title":"Performance Tips","text":"merge(rs...)","category":"page"},{"location":"benchmark.html#Benchmark-Comparison-between-Streaming-and-Non-Streaming-Methods","page":"Benchmarks","title":"Benchmark Comparison between Streaming and Non-Streaming Methods","text":"","category":"section"},{"location":"benchmark.html","page":"Benchmarks","title":"Benchmarks","text":"Using these sampling techniques can bring down considerably the memory usage of the program,  but there are cases where they are also more time efficient, as demostrated below with a comparison with the  equivalent methods of StatsBase.sample:","category":"page"},{"location":"benchmark.html","page":"Benchmarks","title":"Benchmarks","text":"(Image: comparison_stream_algs)","category":"page"},{"location":"benchmark.html","page":"Benchmarks","title":"Benchmarks","text":"The “collection-based with setup” methods consider collecting the iterator in memory as part of the benchmark. The code to reproduce the results is in benchmarkcomparisonstream.jl.","category":"page"},{"location":"index.html#StreamSampling.jl","page":"StreamSampling.jl","title":"StreamSampling.jl","text":"","category":"section"},{"location":"index.html#StreamSampling","page":"StreamSampling.jl","title":"StreamSampling","text":"StreamSampling.jl\n\n(Image: CI) (Image: ) (Image: codecov) (Image: Aqua QA) (Image: DOI)\n\nThe scope of this package is to provide general methods to sample from any stream in a single pass through the data, even when  the number of items contained in the stream is unknown.\n\nThis has some advantages over other sampling procedures:\n\nIf the iterable is lazy, the memory required is a small constant or grows in relation to the size of the sample, instead of the all population.\nWith reservoir methods, the sample collected is a random sample of the portion of the stream seen thus far at any point of the sampling process.\nIn some cases, sampling with the techniques implemented in this library can bring considerable performance gains, since the population of items doesn't need to be previously stored in memory.\n\nFor information about the available functionalities consult the documentation.\n\nContributing\n\nContributions are welcome! If you encounter any issues, have suggestions for improvements, or would like to add new  features, feel free to open an issue or submit a pull request.\n\n\n\n\n\n","category":"module"},{"location":"index.html#Reproducibility","page":"StreamSampling.jl","title":"Reproducibility","text":"","category":"section"},{"location":"index.html","page":"StreamSampling.jl","title":"StreamSampling.jl","text":"<details><summary>The documentation of StreamSampling.jl was built using these direct dependencies,</summary>","category":"page"},{"location":"index.html","page":"StreamSampling.jl","title":"StreamSampling.jl","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"index.html","page":"StreamSampling.jl","title":"StreamSampling.jl","text":"</details>","category":"page"},{"location":"index.html","page":"StreamSampling.jl","title":"StreamSampling.jl","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"index.html","page":"StreamSampling.jl","title":"StreamSampling.jl","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"index.html","page":"StreamSampling.jl","title":"StreamSampling.jl","text":"</details>","category":"page"},{"location":"index.html","page":"StreamSampling.jl","title":"StreamSampling.jl","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"index.html","page":"StreamSampling.jl","title":"StreamSampling.jl","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"index.html","page":"StreamSampling.jl","title":"StreamSampling.jl","text":"</details>","category":"page"},{"location":"index.html","page":"StreamSampling.jl","title":"StreamSampling.jl","text":"using TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/StreamSampling/\" * name * \".jl/tree/gh-pages/v\" * version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/StreamSampling/\" * name * \".jl/tree/gh-pages/v\" * version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"page"},{"location":"example.html#An-Illustrative-Example","page":"An Illustrative Example","title":"An Illustrative Example","text":"","category":"section"},{"location":"example.html","page":"An Illustrative Example","title":"An Illustrative Example","text":"Suppose to receive data about some process in the form of a stream and you want to detect if anything is going wrong in the data being received. A reservoir  sampling approach could be useful to evaluate properties on the data stream.  This is a demonstration of such a use case using StreamSampling.jl. We will assume that the monitored statistic in this case is the mean of the data, and  you want that to be lower than a certain threshold otherwise some malfunctioning is expected.","category":"page"},{"location":"example.html","page":"An Illustrative Example","title":"An Illustrative Example","text":"using StreamSampling, Statistics, Random\n\nfunction monitor(stream, thr)\n    rng = Xoshiro(42)\n    # we use a reservoir sample of 10^4 elements\n    rs = ReservoirSampler{Int}(rng, 10^4)\n    # we loop over the stream and fit the data in the reservoir\n    for (i, e) in enumerate(stream)\n        fit!(rs, e)\n        # we check the mean value every 1000 iterations\n        if iszero(mod(i, 1000)) && mean(value(rs)) >= thr\n            return rs\n        end\n    end\nend","category":"page"},{"location":"example.html","page":"An Illustrative Example","title":"An Illustrative Example","text":"We use some toy data for illustration","category":"page"},{"location":"example.html","page":"An Illustrative Example","title":"An Illustrative Example","text":"stream = 1:10^8; # the data stream\nthr = 2*10^7; # the threshold for the mean monitoring","category":"page"},{"location":"example.html","page":"An Illustrative Example","title":"An Illustrative Example","text":"Then, we run the monitoring","category":"page"},{"location":"example.html","page":"An Illustrative Example","title":"An Illustrative Example","text":"rs = monitor(stream, thr);","category":"page"},{"location":"example.html","page":"An Illustrative Example","title":"An Illustrative Example","text":"The number of observations until the detection is triggered is given by","category":"page"},{"location":"example.html","page":"An Illustrative Example","title":"An Illustrative Example","text":"nobs(rs)","category":"page"},{"location":"example.html","page":"An Illustrative Example","title":"An Illustrative Example","text":"which is very close to the true value of 4*10^7 - 1 observations.","category":"page"},{"location":"example.html","page":"An Illustrative Example","title":"An Illustrative Example","text":"Note that in this case we could use an online mean methods,  instead of holding all the sample into memory. However,  the approach with the sample is more general because it allows to estimate any statistic about the stream. ","category":"page"}]
}
