var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/#StreamSampling.ReservoirSampler","page":"API","title":"StreamSampling.ReservoirSampler","text":"ReservoirSampler{T}([rng], method = AlgRSWRSKIP())\nReservoirSampler{T}([rng], n::Int, method = AlgL(); ordered = false)\n\nInitializes a reservoir sampler with elements of type T.\n\nThe first signature represents a sample where only a single element is collected. If ordered is true, the sampled values can be retrived in the order they were collected using ordvalue.\n\nLook at the Sampling Algorithms section for the supported methods. \n\n\n\n\n\n","category":"type"},{"location":"api/#StreamSampling.StreamSampler","page":"API","title":"StreamSampling.StreamSampler","text":"StreamSampler{T}([rng], iter, n, [N], method = AlgD())\n\nInitializes a stream sampler, which can then be iterated over to return the sampling elements of the iterable iter which is assumed to have a eltype of T. The methods implemented in StreamSampler require the knowledge of the total number of elements in the stream N, if not provided it is assumed to be available by calling length(iter).\n\n\n\n\n\n","category":"type"},{"location":"api/#Methods","page":"API","title":"Methods","text":"","category":"section"},{"location":"api/#StatsAPI.fit!","page":"API","title":"StatsAPI.fit!","text":"fit!(rs::AbstractReservoirSampler, el)\nfit!(rs::AbstractReservoirSampler, el, w)\n\nUpdates the reservoir sample by taking into account the element passed. If the sampling is weighted also the weight of the elements needs to be passed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.merge!","page":"API","title":"Base.merge!","text":"Base.merge!(rs::AbstractReservoirSampler, rs_others::AbstractReservoirSampler...)\n\nUpdates the first reservoir sampler by merging its value with the values of the other samplers. The number of elements after merging will be the minimum number of elements in the merged reservoirs.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.merge","page":"API","title":"Base.merge","text":"Base.merge(rs_all::AbstractReservoirSampler...)\n\nCreates a new reservoir sampler by merging the values of the samplers passed. The number of elements in the new sampler will be the minimum number of elements in the merged reservoirs.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.empty!","page":"API","title":"Base.empty!","text":"Base.empty!(rs::AbstractReservoirSampler)\n\nResets the reservoir sample to its initial state.  Useful to avoid allocating a new sampler in some cases.\n\n\n\n\n\n","category":"function"},{"location":"api/#OnlineStatsBase.value","page":"API","title":"OnlineStatsBase.value","text":"value(rs::AbstractReservoirSampler)\n\nReturns the elements collected in the sample at the current  sampling stage.\n\nIf the sampler is empty, it returns nothing for single element sampling. For multi-valued samplers, it always returns the sample collected so far instead.\n\nNote that even if the sampling respects the schema it is assigned when ReservoirSampler is instantiated, some ordering in  the sample can be more probable than others. To represent each one  with the same probability call fshuffle! on the result.\n\n\n\n\n\n","category":"function"},{"location":"api/#StreamSampling.ordvalue","page":"API","title":"StreamSampling.ordvalue","text":"ordvalue(rs::AbstractReservoirSampler)\n\nReturns the elements collected in the sample at the current  sampling stage in the order they were collected. This applies only when ordered = true is passed in ReservoirSampler.\n\nIf the sampler is empty, it returns nothing for single element sampling. For multi-valued samplers, it always returns the sample collected so far instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsAPI.nobs","page":"API","title":"StatsAPI.nobs","text":"nobs(rs::AbstractReservoirSampler)\n\nReturns the total number of elements that have been observed so far  during the sampling process.\n\n\n\n\n\n","category":"function"},{"location":"api/#StreamSampling.itsample","page":"API","title":"StreamSampling.itsample","text":"itsample([rng], iter, method = AlgRSWRSKIP())\nitsample([rng], iter, wfunc, method = AlgWRSWRSKIP())\n\nReturn a random element of the iterator, optionally specifying a rng  (which defaults to Random.default_rng()) and a function wfunc which accept each element as input and outputs the corresponding weight. If the iterator is empty, it returns nothing.\n\n\n\nitsample([rng], iter, n::Int, method = AlgL(); ordered = false)\nitsample([rng], iter, wfunc, n::Int, method = AlgAExpJ(); ordered = false)\n\nReturn a vector of n random elements of the iterator,  optionally specifying a rng (which defaults to Random.default_rng()) a weight function wfunc and a method. ordered dictates whether an  ordered sample (also called a sequential sample, i.e. a sample where items  appear in the same order as in iter) must be collected.\n\nIf the iterator has less than n elements, in the case of sampling without replacement, it returns a vector of those elements.\n\n\n\n\n\n","category":"function"},{"location":"api/#Algorithms","page":"API","title":"Algorithms","text":"","category":"section"},{"location":"api/#StreamSampling.AlgR","page":"API","title":"StreamSampling.AlgR","text":"Implements random reservoir sampling without replacement. To be used with ReservoirSampler or itsample.\n\nAdapted from algorithm R described in \"Random sampling with a reservoir, J. S. Vitter, 1985\".\n\n\n\n\n\n","category":"type"},{"location":"api/#StreamSampling.AlgL","page":"API","title":"StreamSampling.AlgL","text":"Implements random reservoir sampling without replacement. To be used with ReservoirSampler or itsample.\n\nAdapted from algorithm L described in \"Random sampling with a reservoir, J. S. Vitter, 1985\".\n\n\n\n\n\n","category":"type"},{"location":"api/#StreamSampling.AlgRSWRSKIP","page":"API","title":"StreamSampling.AlgRSWRSKIP","text":"Implements random reservoir sampling with replacement. To be used with ReservoirSampler or itsample.\n\nAdapted fron algorithm RSWR-SKIP described in \"Reservoir-based Random Sampling with Replacement from  Data Stream, B. Park et al., 2008\".\n\n\n\n\n\n","category":"type"},{"location":"api/#StreamSampling.AlgARes","page":"API","title":"StreamSampling.AlgARes","text":"Implements weighted random reservoir sampling without replacement. To be used with ReservoirSampler or itsample.\n\nAdapted from algorithm A-Res described in \"Weighted random sampling with a reservoir, P. S. Efraimidis et al., 2006\".\n\n\n\n\n\n","category":"type"},{"location":"api/#StreamSampling.AlgAExpJ","page":"API","title":"StreamSampling.AlgAExpJ","text":"Implements weighted random reservoir sampling without replacement. To be used with ReservoirSampler or itsample.\n\nAdapted from algorithm A-ExpJ described in \"Weighted random sampling with a reservoir, P. S. Efraimidis et al., 2006\".\n\n\n\n\n\n","category":"type"},{"location":"api/#StreamSampling.AlgWRSWRSKIP","page":"API","title":"StreamSampling.AlgWRSWRSKIP","text":"Implements weighted random reservoir sampling with replacement. To be used with ReservoirSampler or itsample.\n\nAdapted from algorithm WRSWR-SKIP described in \"Investigating Methods for Weighted Reservoir Sampling with Replacement, A. Meligrana, 2024\".\n\n\n\n\n\n","category":"type"},{"location":"api/#StreamSampling.AlgD","page":"API","title":"StreamSampling.AlgD","text":"Implements random stream sampling without replacement. To be used with StreamSampler or itsample.\n\nAdapted from algorithm D described in \"An Efficient Algorithm for Sequential Random Sampling, J. S. Vitter, 1987\".\n\n\n\n\n\n","category":"type"},{"location":"api/#StreamSampling.AlgORDSWR","page":"API","title":"StreamSampling.AlgORDSWR","text":"Implements random stream sampling with replacement. To be used with StreamSampler or itsample.\n\nAdapted from algorithm 4 described in \"Generating Sorted Lists of Random Numbers, J. L. Bentley et al., 1980\".\n\n\n\n\n\n","category":"type"},{"location":"basics/#Overview-of-the-functionalities","page":"Basics","title":"Overview of the functionalities","text":"","category":"section"},{"location":"basics/","page":"Basics","title":"Basics","text":"The itsample function allows to consume all the stream at once and return the sample collected:","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"using StreamSampling\n\nst = 1:100;\n\nitsample(st, 5)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"In some cases, one needs to control the updates the ReservoirSampler will be subject to. In this case you can simply use the fit! function to update the reservoir:","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"st = 1:100;\n\nrs = ReservoirSampler{Int}(5);\n\nfor x in st\n    fit!(rs, x)\nend\n\nvalue(rs)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"If the total number of elements in the stream is known beforehand and the sampling is unweighted, it is also possible to iterate over a StreamSampler like so","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"st = 1:100;\n\nss = StreamSampler{Int}(st, 5, 100);\n\nr = Int[];\n\nfor x in ss\n    push!(r, x)\nend\n\nr","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"The advantage of StreamSampler iterators in respect to ReservoirSampler is that they require O(1) memory if not collected, while reservoir techniques require O(k) memory where k is the number of elements in the sample.","category":"page"},{"location":"perf_tips/#Performance-Tips","page":"Performance Tips","title":"Performance Tips","text":"","category":"section"},{"location":"perf_tips/#Use-Immutable-Reservoir-Samplers","page":"Performance Tips","title":"Use Immutable Reservoir Samplers","text":"","category":"section"},{"location":"perf_tips/","page":"Performance Tips","title":"Performance Tips","text":"By default, a ReservoirSampler is mutable, however, it is also possible to use an immutable version which supports all the basic operations. It uses Accessors.jl under the hood to update the reservoir.","category":"page"},{"location":"perf_tips/","page":"Performance Tips","title":"Performance Tips","text":"Let's compare the performance of mutable and immutable samplers with a simple benchmark","category":"page"},{"location":"perf_tips/","page":"Performance Tips","title":"Performance Tips","text":"using StreamSampling, BenchmarkTools\n\nfunction fit_iter!(rs, iter)\n    for i in iter\n        rs = fit!(rs, i) # the reassignment is necessary when `rs` is immutable\n    end\n    return rs\nend\n\niter = 1:10^7;","category":"page"},{"location":"perf_tips/","page":"Performance Tips","title":"Performance Tips","text":"Running with both version we get","category":"page"},{"location":"perf_tips/","page":"Performance Tips","title":"Performance Tips","text":"@btime fit_iter!(rs, $iter) setup=(rs = ReservoirSampler{Int}(10, AlgRSWRSKIP(); mutable = true))","category":"page"},{"location":"perf_tips/","page":"Performance Tips","title":"Performance Tips","text":"  6.535 ms (2 allocations: 144 bytes)","category":"page"},{"location":"perf_tips/","page":"Performance Tips","title":"Performance Tips","text":"@btime fit_iter!(rs, $iter) setup=(rs = ReservoirSampler{Int}(10, AlgRSWRSKIP(); mutable = false))","category":"page"},{"location":"perf_tips/","page":"Performance Tips","title":"Performance Tips","text":"  4.816 ms (2 allocations: 144 bytes)","category":"page"},{"location":"perf_tips/","page":"Performance Tips","title":"Performance Tips","text":"As you can see, the immutable version is 50% faster than  the mutable one. In general, more the ratio between reservoir  size and stream size is smaller, more the immutable version will be faster than the mutable one. Be careful though, because calling fit! on an immutable sampler won't modify it in-place, but only create a new updated instance.","category":"page"},{"location":"perf_tips/#Parallel-Sampling-from-Multiple-Streams","page":"Performance Tips","title":"Parallel Sampling from Multiple Streams","text":"","category":"section"},{"location":"perf_tips/","page":"Performance Tips","title":"Performance Tips","text":"Let's say that you want to split the sampling of an iterator. If you can split the iterator into different partitions then you can update in parallel a reservoir sample for each partition and then merge them together at the end.","category":"page"},{"location":"perf_tips/","page":"Performance Tips","title":"Performance Tips","text":"Suppose for instance to have these 2 iterators","category":"page"},{"location":"perf_tips/","page":"Performance Tips","title":"Performance Tips","text":"iters = [1:100, 101:200]","category":"page"},{"location":"perf_tips/","page":"Performance Tips","title":"Performance Tips","text":"then you create two reservoirs of the same type","category":"page"},{"location":"perf_tips/","page":"Performance Tips","title":"Performance Tips","text":"rs = [ReservoirSampler{Int}(10, AlgRSWRSKIP()) for i in 1:length(iters)]","category":"page"},{"location":"perf_tips/","page":"Performance Tips","title":"Performance Tips","text":"and after that you can just update them in parallel like so","category":"page"},{"location":"perf_tips/","page":"Performance Tips","title":"Performance Tips","text":"Threads.@threads for i in 1:length(iters)\n    for e in iters[i]\n        fit!(rs[i], e)\n    end\nend","category":"page"},{"location":"perf_tips/","page":"Performance Tips","title":"Performance Tips","text":"then you can obtain a unique reservoir containing a summary of the union of the streams with","category":"page"},{"location":"perf_tips/","page":"Performance Tips","title":"Performance Tips","text":"merge(rs...)","category":"page"},{"location":"benchmark/#Benchmark-Comparison-between-Streaming-and-Non-Streaming-Methods","page":"Benchmarks","title":"Benchmark Comparison between Streaming and Non-Streaming Methods","text":"","category":"section"},{"location":"benchmark/","page":"Benchmarks","title":"Benchmarks","text":"Using these sampling techniques can bring down considerably the memory usage of the program,  but there are cases where they are also more time efficient, as demostrated below with a comparison with the  equivalent methods of StatsBase.sample:","category":"page"},{"location":"benchmark/","page":"Benchmarks","title":"Benchmarks","text":"(Image: comparison_stream_algs)","category":"page"},{"location":"benchmark/","page":"Benchmarks","title":"Benchmarks","text":"The “collection-based with setup” methods consider collecting the iterator in memory as part of the benchmark. The code to reproduce the results is in benchmarkcomparisonstream.jl.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#StreamSampling","page":"Introduction","title":"StreamSampling","text":"StreamSampling.jl\n\n(Image: CI) (Image: ) (Image: codecov) (Image: Aqua QA) (Image: DOI)\n\nThe scope of this package is to provide general methods to sample from any stream in a single pass through the data, even when  the number of items contained in the stream is unknown.\n\nThis has some advantages over other sampling procedures:\n\nIf the iterable is lazy, the memory required is a small constant or grows in relation to the size of the sample, instead of all the population.\nWith reservoir methods, the sample collected is a random sample of the portion of the stream seen thus far at any point of the sampling process.\nIn some cases, sampling with the techniques implemented in this library can bring considerable performance gains, since the population of items doesn't need to be previously stored in memory.\n\nFor information about the available functionalities consult the documentation.\n\nContributing\n\nContributions are welcome! If you encounter any issues, have suggestions for improvements, or would like to add new  features, feel free to open an issue or submit a pull request.\n\n\n\n\n\n","category":"module"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(\"StreamSampling\")","category":"page"},{"location":"#Reproducibility","page":"Introduction","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"<details><summary>The documentation of StreamSampling.jl was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"</details>","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"</details>","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"</details>","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/StreamSampling/\" * name * \".jl/tree/gh-pages/v\" * version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/StreamSampling/\" * name * \".jl/tree/gh-pages/v\" * version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"page"},{"location":"example/#Illustrative-Examples","page":"An Illustrative Example","title":"Illustrative Examples","text":"","category":"section"},{"location":"example/#Sampling-from-Data-on-Disk","page":"An Illustrative Example","title":"Sampling from Data on Disk","text":"","category":"section"},{"location":"example/","page":"An Illustrative Example","title":"An Illustrative Example","text":"Suppose we want to sample from large datasets stored on disk. StreamSampling.jl is very suited for this task. Let's simulate this task by generating some data in  HDF5 format and batch sampling them. You will need 10GB of space on disk for running this example. If not available you can set a smaller size for totaltuples.","category":"page"},{"location":"example/","page":"An Illustrative Example","title":"An Illustrative Example","text":"We first generate the dataset and store it with","category":"page"},{"location":"example/","page":"An Illustrative Example","title":"An Illustrative Example","text":"using StreamSampling, Random, ChunkSplitters, HDF5\n\nconst dtype = @NamedTuple{a::Float64, b::Float64, c::Float64, d::Float64}\nconst totaltuples = 10^10÷32\nconst chunktuples = 5*10^5\nconst numchunks = ceil(Int, totaltuples / chunktuples)\n\nfunction generate_large_hdf5_file(filename)\n    h5open(filename, \"w\") do file\n        dset = create_dataset(file, \"data\", dtype, (totaltuples,), chunk=(chunktuples,))\n        Threads.@threads for i in 1:numchunks\n            startrow, endrow = (i-1)*chunktuples+1, min(i*chunktuples, totaltuples)\n            dset[startrow:endrow] = map(i -> (a=rand(), b=rand(), c=rand(), d=rand()), \n                                        1:endrow-startrow+1)\n        end\n    end\nend\n\n!isfile(\"large_random_data.h5\") && generate_large_hdf5_file(\"large_random_data.h5\")","category":"page"},{"location":"example/","page":"An Illustrative Example","title":"An Illustrative Example","text":"Then we can sample it using 1 thread with","category":"page"},{"location":"example/","page":"An Illustrative Example","title":"An Illustrative Example","text":"function sample_large_hdf5_file(filename, rng, n, alg)\n    rs = ReservoirSampler{dtype}(rng, n, alg)\n    h5open(filename, \"r\") do file\n        dset = file[\"data\"]\n        for i in 1:numchunks\n            startrow, endrow = (i-1)*chunktuples+1, min(i*chunktuples, totaltuples)\n            data_chunk = dset[startrow:endrow]\n            for d in data_chunk\n                fit!(rs, d)\n            end\n        end\n    end\n    return rs\nend\n\nrng = Xoshiro(42)\n@time rs = sample_large_hdf5_file(\"large_random_data.h5\", rng, 10^7, AlgRSWRSKIP())","category":"page"},{"location":"example/","page":"An Illustrative Example","title":"An Illustrative Example","text":" 43.514238 seconds (937.21 M allocations: 42.502 GiB, 2.57% gc time)","category":"page"},{"location":"example/","page":"An Illustrative Example","title":"An Illustrative Example","text":"We can try to improve the performance by using multiple threads. Here, I started Julia with julia -t6 --gcthreads=6,1 on my machine","category":"page"},{"location":"example/","page":"An Illustrative Example","title":"An Illustrative Example","text":"function psample_large_hdf5_file(filename, rngs, n, alg)\n    rsv = [ReservoirSampler{DATATYPE}(rngs[i], n, alg) for i in 1:Threads.nthreads()]\n    h5open(filename, \"r\") do file\n        dset = file[\"data\"]\n        for c in chunks(1:numchunks; n=ceil(Int, numchunks/Threads.nthreads()))\n            Threads.@threads for (j, i) in collect(enumerate(c))\n                startrow, endrow = (i-1)*chunktuples+1, min(i*chunktuples, totaltuples)\n                data_chunk, rs = dset[startrow:endrow], rsv[j]\n                for d in data_chunk\n                    fit!(rs, d)\n                end\n            end\n        end\n    end\n    return merge(rsv...)\nend\n\nrngs = [Xoshiro(i) for i in 1:Threads.nthreads()]\n@time rs = psample_large_hdf5_file(\"large_random_data.h5\", rngs, 10^7, AlgRSWRSKIP())","category":"page"},{"location":"example/","page":"An Illustrative Example","title":"An Illustrative Example","text":" 21.545665 seconds (937.21 M allocations: 46.525 GiB, 9.50% gc time, 14913 lock conflicts)","category":"page"},{"location":"example/","page":"An Illustrative Example","title":"An Illustrative Example","text":"As you can see, the speed-up is not linear in the number of threads. This is mainly due to the fact that accessing the chunks is single-threaded, so one would need to use MPI.jl as  explained at https://juliaio.github.io/HDF5.jl/stable/mpi/ to improve the multi-threading performance. Though, we are already sampling at 500MB/S, which is not bad!","category":"page"},{"location":"example/#Monitoring","page":"An Illustrative Example","title":"Monitoring","text":"","category":"section"},{"location":"example/","page":"An Illustrative Example","title":"An Illustrative Example","text":"Suppose to receive data about some process in the form of a stream and you want to detect if anything is going wrong in the data being received. A reservoir  sampling approach could be useful to evaluate properties on the data stream.  This is a demonstration of such a use case using StreamSampling.jl. We will assume that the monitored statistic in this case is the mean of the data, and  you want that to be lower than a certain threshold otherwise some malfunctioning is expected","category":"page"},{"location":"example/","page":"An Illustrative Example","title":"An Illustrative Example","text":"using StreamSampling, Statistics, Random\n\nfunction monitor(stream, thr)\n    rng = Xoshiro(42)\n    # we use a reservoir sample of 10^4 elements\n    rs = ReservoirSampler{Int}(rng, 10^4)\n    # we loop over the stream and fit the data in the reservoir\n    for (i, e) in enumerate(stream)\n        fit!(rs, e)\n        # we check the mean value every 1000 iterations\n        if iszero(mod(i, 1000)) && mean(value(rs)) >= thr\n            return rs\n        end\n    end\nend","category":"page"},{"location":"example/","page":"An Illustrative Example","title":"An Illustrative Example","text":"We use some toy data for illustration","category":"page"},{"location":"example/","page":"An Illustrative Example","title":"An Illustrative Example","text":"stream = 1:10^8; # the data stream\nthr = 2*10^7; # the threshold for the mean monitoring","category":"page"},{"location":"example/","page":"An Illustrative Example","title":"An Illustrative Example","text":"Then, we run the monitoring","category":"page"},{"location":"example/","page":"An Illustrative Example","title":"An Illustrative Example","text":"rs = monitor(stream, thr);","category":"page"},{"location":"example/","page":"An Illustrative Example","title":"An Illustrative Example","text":"The number of observations until the detection is triggered is given by","category":"page"},{"location":"example/","page":"An Illustrative Example","title":"An Illustrative Example","text":"nobs(rs)","category":"page"},{"location":"example/","page":"An Illustrative Example","title":"An Illustrative Example","text":"which is very close to the true value of 4*10^7 - 1 observations.","category":"page"},{"location":"example/","page":"An Illustrative Example","title":"An Illustrative Example","text":"Note that in this case we could use an online mean methods,  instead of holding all the sample into memory. However,  the approach with the sample is more general because it allows to estimate any statistic about the stream. ","category":"page"}]
}
